//+------------------------------------------------------------------+
//|                                                       test10.mq5 |
//|                                  Copyright 2024, MetaQuotes Ltd. |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "2.33"
#property strict

#include <Trade\Trade.mqh>
CTrade trade;

// ===================================================================
// 定数（コンパイル時定数）
// ===================================================================
#define CACHE_BARS 3
#define DIVERGENCE_PERIOD 100
#define REQ_CAP 1024
#define MAX_HISTORY 100

// ===================================================================
// 列挙型（仕様コメントは日本語で保持）
// ===================================================================
//--- トレンド・相場状態
enum TrendType
{
   TREND_STRONG_UP,     // 強い上昇トレンド （DI＋EMA両方満たす）
   TREND_WEAK_UP,       // 弱い上昇トレンド （DIまたはEMAどちらかのみ満たす）
   TREND_STRONG_DOWN,   // 強い下降トレンド （DI＋EMA両方満たす）
   TREND_WEAK_DOWN,     // 弱い下降トレンド （DIまたはEMAどちらかのみ満たす）
   TREND_RANGE,         // レンジ相場
   TREND_UNKNOWN        // 相場不明
};

//--- トレンドの状態（成長/減速等）
enum TrendState
{
   TREND_ACCELERATE,    // トレンド加速
   TREND_DECELERATE,    // トレンド減速
   TREND_MAINTAIN,      // トレンド維持
   RANGE_MAINTAIN,      // レンジ維持
   RANGE_TO_TREND,      // レンジ⇒トレンド移行 （強弱問わず）
   TREND_TO_RANGE,      // トレンド⇒レンジ移行
   STATE_UNKNOWN        // 判定不能
};

//--- ダイバージェンス判定用enum
enum DivergenceType
{
   DIVERGENCE_NONE,     // ダイバージェンスなし
   DIVERGENCE_BULLISH,  // 強気（ブル）ダイバージェンス （価格が下降/指標が上昇）
   DIVERGENCE_BEARISH,  // 弱気（ベア）ダイバージェンス （価格が上昇/指標が下降）
   DIVERGENCE_CONFLICT  // 強気・弱気両方同時発生
};

//--- 過熱感判定enum
enum OverheatType
{
   OVERHEAT_NONE,       // 過熱なし
   OVERHEAT_OVERBOUGHT, // 買われすぎ（上昇過熱）
   OVERHEAT_OVERSOLD    // 売られすぎ（下降過熱）
};

// ===================================================================
// ユーザー入力（必要最小限）
// ===================================================================
input int    MagicNumber           = 3625;
input double BaseLot               = 1.0;
input double MaxLot                = 2.0;
input double RiskPercentEquity     = 1.0;
input int    Max_Positions_Range   = 1;
input int    Max_Positions_Trend   = 10;
input int    MaxAllowedSpread      = 25;     // ポイント
input int    SL_Points             = 40;
input double RiskRewardRatio       = 2.0;

// ===================================================================
// 内部パラメータ（input にはしない）
// ===================================================================
int adxPeriod = 14;
int adxThreshold = 25;
int adxStrongThreshold = 40;
int diMinUnknown = 10;
int diThreshold = 5;
int emaShortPeriod = 20;
int emaLongPeriod  = 50;

int rsiPeriod = 14;
int rsiOverbought = 70;
int rsiOversold = 30;
int macdFast = 12, macdSlow = 26, macdSignal = 9;

int bbPeriod = 20;
int bbDeviation = 2; // int に変更（警告回避）

int stochK = 5, stochD = 3, stochSlowing = 3;
int stochOverbought = 80, stochOversold = 20;

int atrPeriod = 14;
double atrMultiplierSL = 1.5;
double atrMultiplierTrail = 1.5;
double atrStopLowFactor = 0.5;

double lot_range = 0.5;
double lot_weak_trend = 1.0;
double lot_strong_trend = 1.5;
int pyramid_additional_allowed = 1;

// ===================================================================
// インジケータハンドル（OnInit で作成）
// ===================================================================
int h_adx = INVALID_HANDLE;
int h_emaS = INVALID_HANDLE;
int h_emaL = INVALID_HANDLE;
int h_rsi = INVALID_HANDLE;
int h_macd = INVALID_HANDLE;
int h_bb = INVALID_HANDLE;
int h_stoch = INVALID_HANDLE;
int h_atr = INVALID_HANDLE;

// ===================================================================
// 1分足の指標値をグローバルで保持（要求）
// index 0 = 最新確定バー（bar1）
// ===================================================================
double g_bbUpper[CACHE_BARS];
double g_bbMiddle[CACHE_BARS];
double g_bbLower[CACHE_BARS];
double g_stochK[CACHE_BARS];
double g_stochD[CACHE_BARS];
double g_atr[CACHE_BARS];
double g_superTrend[CACHE_BARS];
int    g_superTrendDir[CACHE_BARS];

// ===================================================================
// 判定結果をグローバル enum として保持（H1/M15）
// ===================================================================
TrendType      g_TrendTypeH = TREND_UNKNOWN;
TrendState     g_TrendStateH = STATE_UNKNOWN;
double         g_TrendValueH = 0.0;
TrendState     g_TrendStateM15 = STATE_UNKNOWN;
double         g_TrendValueM15 = 0.0;
DivergenceType g_DivergenceM15 = DIVERGENCE_NONE;
OverheatType   g_OverheatM15 = OVERHEAT_NONE;

// ===================================================================
// M15 のシグナル管理構造体（ダイバージェンス・MACDクロス）
//  - シグナルは M15 の次の M1 足でのみ有効（pendingNextM1）
//  - 発生時に usedForEntry/usedForClose を false にしておく
//  - 一度使用されたら usedForEntry/usedForClose を true にして適用を防ぐ
// ===================================================================
struct SM15Signal
{
   datetime barTime;
   bool hasDiv;
   DivergenceType divType;
   bool hasMACDCross;
   int macdCrossDir; // 1=ゴールデンクロス, -1=デッドクロス
   bool pendingNextM1;
   bool usedForEntry;
   bool usedForClose;
};
SM15Signal g_M15Signal;

// ===================================================================
// リクエスト制限／履歴
// ===================================================================
ulong ReqTimes[REQ_CAP];
int ReqCount = 0;
datetime TradeHistory[MAX_HISTORY];
int TradeHistorySize = 0;
ulong StartTimeGlobal = 0;

ulong NowMs() { return (GetTickCount64()); }
void PushReq(ulong t)
{
    if (ReqCount < REQ_CAP) ReqTimes[ReqCount++] = t;
    else { for (int i = 1; i < ReqCount; i++) ReqTimes[i - 1] = ReqTimes[i]; ReqTimes[ReqCount - 1] = t; }
}
int CountReqSince(ulong window_ms)
{
    if (ReqCount == 0) return 0;
    ulong now = NowMs();
    int cnt = 0;
    for (int i = ReqCount - 1; i >= 0; i--)
    {
        if (now - ReqTimes[i] <= window_ms) cnt++;
        else break;
    }
    return (cnt);
}
bool CanReq(bool urgent = false)
{
    int window = RequestWindowMS();
    if (urgent) window = MathMax(200, RequestWindowMS() / 2);
    return (CountReqSince(window) < RequestLimitCount());
}
void RegReq() { PushReq(NowMs()); }

int RequestLimitCount() { return 20; }
int RequestWindowMS() { return 2000; }

void AddTradeHistoryTimestamp(datetime t)
{
    if (TradeHistorySize < MAX_HISTORY)
    {
        for (int i = TradeHistorySize; i > 0; i--) TradeHistory[i] = TradeHistory[i - 1];
        TradeHistory[0] = t;
        TradeHistorySize++;
    }
    else
    {
        for (int i = MAX_HISTORY - 1; i > 0; i--) TradeHistory[i] = TradeHistory[i - 1];
        TradeHistory[0] = t;
    }
}

// ===================================================================
// ダイバージェンス補助（配列は参照で渡す）
// ===================================================================
void FindPeaks(const double &arr[], int period, bool mode, int minDistance, int peakCount, int &outIdx[])
{
    ArrayInitialize(outIdx, -1);
    int found = 0;
    int lastIdx = -minDistance - 1;
    for (int i = 0; i < period && found < peakCount; i++)
    {
        bool isPeak = true;
        for (int j = -1; j <= 1; j++)
        {
            int k = i + j;
            if (k < 0 || k >= period) continue;
            if ((mode && arr[i] < arr[k]) || (!mode && arr[i] > arr[k]))
            {
                isPeak = false;
                break;
            }
        }
        if (isPeak && (i - lastIdx) >= minDistance)
        {
            outIdx[found] = i;
            lastIdx = i;
            found++;
        }
    }
}

int FindIndicatorPeak(double &indi[], int center, int period, bool mode, int win, bool &used[])
{
    int start = MathMax(0, center - win);
    int end = MathMin(period - 1, center + win);
    int idx = -1;
    double val = mode ? -DBL_MAX : DBL_MAX;
    for (int i = start; i <= end; i++)
    {
        if (used[i]) continue;
        if ((mode && indi[i] > val) || (!mode && indi[i] < val))
        {
            val = indi[i];
            idx = i;
        }
    }
    if (idx >= 0) used[idx] = true;
    return (idx);
}

DivergenceType CheckDivergenceFull(string symbol, ENUM_TIMEFRAMES timeframe, double &indicator[], int period, int peakCount = 3, int minDistance = 2, int win = 2)
{
    double highs[], lows[];
    if (CopyHigh(symbol, timeframe, 0, period, highs) <= 0 ||
        CopyLow(symbol, timeframe, 0, period, lows) <= 0)
    {
        Print("ダイバージェンス判定用の価格データ取得に失敗しました。");
        return (DIVERGENCE_NONE);
    }
    ArraySetAsSeries(highs, true);
    ArraySetAsSeries(lows, true);

    int high_idx[10];
    int low_idx[10];
    FindPeaks(highs, period, true, minDistance, peakCount, high_idx);
    FindPeaks(lows, period, false, minDistance, peakCount, low_idx);

    bool usedIndi[200];
    ArrayInitialize(usedIndi, false);
    int indiHigh[10];
    int indiLow[10];
    for (int i = 0; i < peakCount; i++)
    {
        indiHigh[i] = high_idx[i] >= 0 ? FindIndicatorPeak(indicator, high_idx[i], period, true, win, usedIndi) : -1;
        indiLow[i] = low_idx[i] >= 0 ? FindIndicatorPeak(indicator, low_idx[i], period, false, win, usedIndi) : -1;
    }

    bool bearish = false;
    bool bullish = false;
    if (high_idx[0] >= 0 && high_idx[1] >= 0 && high_idx[2] >= 0 && indiHigh[0] >= 0 && indiHigh[1] >= 0 && indiHigh[2] >= 0)
    {
        if (highs[high_idx[0]] < highs[high_idx[1]] && highs[high_idx[1]] < highs[high_idx[2]] &&
            indicator[indiHigh[0]] > indicator[indiHigh[1]] && indicator[indiHigh[1]] > indicator[indiHigh[2]])
            bearish = true;
    }
    if (low_idx[0] >= 0 && low_idx[1] >= 0 && low_idx[2] >= 0 && indiLow[0] >= 0 && indiLow[1] >= 0 && indiLow[2] >= 0)
    {
        if (lows[low_idx[0]] > lows[low_idx[1]] && lows[low_idx[1]] > lows[low_idx[2]] &&
            indicator[indiLow[0]] < indicator[indiLow[1]] && indicator[indiLow[1]] < indicator[indiLow[2]])
            bullish = true;
    }
    if (bearish && bullish) return (DIVERGENCE_CONFLICT);
    if (bearish) return (DIVERGENCE_BEARISH);
    if (bullish) return (DIVERGENCE_BULLISH);
    return (DIVERGENCE_NONE);
}

// ===================================================================
// ヘルパー: CopyBuffer を最大 3 回リトライし、成功なら true を返す
// ===================================================================
bool TryCopyBufferWithRetries(int handle, int buf, int start, int count, double &outArr[])
{
   const int RETRIES = 3;
   for (int attempt = 0; attempt < RETRIES; attempt++)
   {
      if (CopyBuffer(handle, buf, start, count, outArr) > 0)
         return true;
        Sleep(100);
   }
   return false;
}

// ===================================================================
// SuperTrend 計算補助（参照渡しの配列）
// ===================================================================
bool ComputeSuperTrendLocal(const string symbol, ENUM_TIMEFRAMES tf, int atrP, double mult, int bars, double &outST[], int &outDir[])
{
    int need = bars + 5;
    double highs[], lows[], closes[], atrArr[];
    if (CopyHigh(symbol, tf, 1, need, highs) <= 0 ||
        CopyLow(symbol, tf, 1, need, lows) <= 0 ||
        CopyClose(symbol, tf, 1, need, closes) <= 0)
        return (false);
    int atrH = iATR(symbol, tf, atrP);
    if (atrH == INVALID_HANDLE) return (false);
    ArrayResize(atrArr, need);
    if (CopyBuffer(atrH, 0, 1, need, atrArr) <= 0) { IndicatorRelease(atrH); return (false); }

    ArraySetAsSeries(highs, true);
    ArraySetAsSeries(lows, true);
    ArraySetAsSeries(closes, true);
    ArraySetAsSeries(atrArr, true);

    double basicUpper[], basicLower[], finalUpper[], finalLower[], finalST[];
    ArrayResize(basicUpper, need);
    ArrayResize(basicLower, need);
    ArrayResize(finalUpper, need);
    ArrayResize(finalLower, need);
    ArrayResize(finalST, need);

    for (int i = 0; i < need; i++)
    {
        double hl2 = (highs[i] + lows[i]) / 2.0;
        basicUpper[i] = hl2 + mult * atrArr[i];
        basicLower[i] = hl2 - mult * atrArr[i];
    }
    for (int i = 0; i < need; i++)
    {
        if (i == 0) { finalUpper[i] = basicUpper[i]; finalLower[i] = basicLower[i]; }
        else
        {
            finalUpper[i] = (basicUpper[i] < finalUpper[i - 1] || closes[i - 1] > finalUpper[i - 1]) ? basicUpper[i] : finalUpper[i - 1];
            finalLower[i] = (basicLower[i] > finalLower[i - 1] || closes[i - 1] < finalLower[i - 1]) ? basicLower[i] : finalLower[i - 1];
        }
        if (i == 0) finalST[i] = finalUpper[i];
        else finalST[i] = (closes[i - 1] <= finalUpper[i - 1]) ? finalLower[i] : finalUpper[i];
    }

    ArrayResize(outST, bars);
    ArrayResize(outDir, bars);
    for (int j = 0; j < bars; j++)
    {
        outST[j] = finalST[j];
        outDir[j] = (closes[j] >= finalST[j]) ? 1 : -1;
    }
    IndicatorRelease(atrH);
    return (true);
}

// ===================================================================
// H1/M15/M1 用クラス（M1を追加）
//  - 各クラスは Calculate() を持ち、内部で指標を取得し、必要情報を getter で提供
//  - M15 クラスはダイバージェンスとMACDクロスの判定を行う
// ===================================================================
class CTrend1H
{
private:
    TrendType m_type;
    TrendState m_state;
    double m_value;
    int adxH, emaSh, emaLh;
public:
    CTrend1H() { m_type = TREND_UNKNOWN; m_state = STATE_UNKNOWN; m_value = 0.0; adxH = emaSh = emaLh = INVALID_HANDLE; }
    void Init(int _adxH, int _emaSh, int _emaLh) { adxH = _adxH; emaSh = _emaSh; emaLh = _emaLh; }
    bool Calculate()
    {
        // OnInit 側でハンドルの検証を行っているためここでは行わない
        const int need = MathMax(3, adxPeriod);
        double adxArr[], diP[], diM[], emaS[], emaL[];
        bool fail_adx = false, fail_diP = false, fail_diM = false, fail_emaS = false, fail_emaL = false;

        if (!TryCopyBufferWithRetries(adxH, 0, 1, need, adxArr)) fail_adx = true;
        if (!TryCopyBufferWithRetries(adxH, 1, 1, need, diP)) fail_diP = true;
        if (!TryCopyBufferWithRetries(adxH, 2, 1, need, diM)) fail_diM = true;
        if (!TryCopyBufferWithRetries(emaSh, 0, 1, need, emaS)) fail_emaS = true;
        if (!TryCopyBufferWithRetries(emaLh, 0, 1, need, emaL)) fail_emaL = true;

        // 取得失敗があれば処理せず抜ける（最新足の更新もしない）
        if (fail_adx || fail_diP || fail_diM || fail_emaS || fail_emaL)
        {
            return(false);
        }
        ArraySetAsSeries(adxArr, true);
        ArraySetAsSeries(diP, true);
        ArraySetAsSeries(diM, true);
        ArraySetAsSeries(emaS, true);
        ArraySetAsSeries(emaL, true);

        PrintFormat("H1 指標: ADX=%.3f, DI+ = %.3f, DI- = %.3f, EMA_S=%.5f, EMA_L=%.5f", adxArr[0], diP[0], diM[0], emaS[0], emaL[0]);

        m_value = adxArr[0];

        if (diP[0] < diMinUnknown && diM[0] < diMinUnknown)
        {
            m_type = TREND_UNKNOWN; m_state = STATE_UNKNOWN; return(true);
        }

        if (adxArr[0] < adxThreshold) m_type = TREND_RANGE;
        else
        {
            if (diP[0] > diM[0])
            {
                if (adxArr[0] >= adxStrongThreshold) m_type = TREND_STRONG_UP;
                else m_type = TREND_WEAK_UP;
            }
            else
            {
                if (adxArr[0] >= adxStrongThreshold) m_type = TREND_STRONG_DOWN;
                else m_type = TREND_WEAK_DOWN;
            }
        }

        if (m_type == TREND_RANGE) m_state = RANGE_MAINTAIN;
        else
        {
            if (adxArr[1] < adxArr[0]) m_state = TREND_ACCELERATE;
            else if (adxArr[1] > adxArr[0]) m_state = TREND_DECELERATE;
            else m_state = TREND_MAINTAIN;
        }
        return(true);
    }
    TrendType getType() const { return (m_type); }
    TrendState getState() const { return (m_state); }
    double getValue() const { return (m_value); }
};

class CTrend15
{
private:
    TrendState m_state;
    OverheatType m_overheat;
    DivergenceType m_div;
    double m_value;
    bool m_macdCross;
    int m_macdCrossDir; // 1 up, -1 down
    int rsiH, macdH;
public:
    CTrend15() { m_state = STATE_UNKNOWN; m_overheat = OVERHEAT_NONE; m_div = DIVERGENCE_NONE; m_value = 0.0; m_macdCross = false; m_macdCrossDir = 0; rsiH = macdH = INVALID_HANDLE; }
    void Init(int _rsiH, int _macdH) { rsiH = _rsiH; macdH = _macdH; }
    bool Calculate(TrendType h1Type)
    {
        // OnInit 側でハンドルの検証を行っているためここでは行わない
        const int need = 3;
        double rsiArr[], macdMain[], macdSig[];
        bool fail_rsi = false, fail_macdMain = false, fail_macdSig = false;

        if (!TryCopyBufferWithRetries(rsiH, 0, 1, need, rsiArr)) fail_rsi = true;
        if (!TryCopyBufferWithRetries(macdH, 0, 2, need + 1, macdMain)) fail_macdMain = true;
        if (!TryCopyBufferWithRetries(macdH, 1, 2, need + 1, macdSig)) fail_macdSig = true;

        // フォールバック: 別オフセットで再取得を試みる
        if (fail_macdMain || fail_macdSig)
        {
            if (fail_macdMain) fail_macdMain = !TryCopyBufferWithRetries(macdH, 0, 1, need, macdMain);
            if (fail_macdSig) fail_macdSig = !TryCopyBufferWithRetries(macdH, 1, 1, need, macdSig);
        }

        // 取得失敗があれば処理せず抜ける（最新足の更新もしない）
        if (fail_rsi || fail_macdMain || fail_macdSig)
        {
            return(false);
        }
        // macdMain and macdSig are series; ensure length
        ArraySetAsSeries(rsiArr, true);
        ArraySetAsSeries(macdMain, true);
        ArraySetAsSeries(macdSig, true);

        double macdHist[3];
        for (int i = 0; i < need; i++) macdHist[i] = macdMain[i] - macdSig[i];

        PrintFormat("M15 指標: RSI=%.3f, MACD_Hist=%.6f", rsiArr[0], macdHist[0]);

        // Overheat/divergence selection
        if (h1Type == TREND_RANGE || h1Type == TREND_UNKNOWN)
        {
            m_value = rsiArr[0];
            if (rsiArr[0] > rsiOverbought) m_overheat = OVERHEAT_OVERBOUGHT;
            else if (rsiArr[0] < rsiOversold) m_overheat = OVERHEAT_OVERSOLD;
            else m_overheat = OVERHEAT_NONE;

            double arrD[DIVERGENCE_PERIOD];
            ArrayInitialize(arrD, 0.0);
            if (CopyBuffer(rsiH, 0, 0, DIVERGENCE_PERIOD, arrD) > 0) m_div = CheckDivergenceFull(_Symbol, PERIOD_M15, arrD, DIVERGENCE_PERIOD);
            else m_div = DIVERGENCE_NONE;
        }
        else
        {
            m_value = macdHist[0];
            if (macdHist[0] > 0) m_overheat = OVERHEAT_OVERBOUGHT;
            else if (macdHist[0] < 0) m_overheat = OVERHEAT_OVERSOLD;
            else m_overheat = OVERHEAT_NONE;

            double mainAll[], sigAll[], histAll[];
            ArrayResize(histAll, DIVERGENCE_PERIOD);
            if (CopyBuffer(macdH, 0, 0, DIVERGENCE_PERIOD, mainAll) > 0 && CopyBuffer(macdH, 1, 0, DIVERGENCE_PERIOD, sigAll) > 0)
            {
                for (int i = 0; i < DIVERGENCE_PERIOD; i++) histAll[i] = mainAll[i] - sigAll[i];
                m_div = CheckDivergenceFull(_Symbol, PERIOD_M15, histAll, DIVERGENCE_PERIOD);
            }
            else m_div = DIVERGENCE_NONE;
        }

        // MACD クロス判定（直近のバーでクロスが発生したか）
        m_macdCross = false;
        m_macdCrossDir = 0;
        // We need at least 3 points (series): index 0 latest completed, 1 prev, 2 prev2
        // Golden: prev2 <= prev1 and prev1 > prev0 (macdMain - macdSig cross upward between prev2->prev1)
        if (ArraySize(macdMain) >= 3 && ArraySize(macdSig) >= 3)
        {
            // cross up: macdMain[2] <= macdSig[2] && macdMain[1] > macdSig[1]
            if (macdMain[2] <= macdSig[2] && macdMain[1] > macdSig[1]) { m_macdCross = true; m_macdCrossDir = 1; }
            else if (macdMain[2] >= macdSig[2] && macdMain[1] < macdSig[1]) { m_macdCross = true; m_macdCrossDir = -1; }
        }
        else
        {
            // Fallback simpler cross detection using index 1 and 2 if available
            if (ArraySize(macdMain) >= 2 && ArraySize(macdSig) >= 2)
            {
                if (macdMain[1] > macdSig[1] && macdMain[2] <= macdSig[2]) { m_macdCross = true; m_macdCrossDir = 1; }
                else if (macdMain[1] < macdSig[1] && macdMain[2] >= macdSig[2]) { m_macdCross = true; m_macdCrossDir = -1; }
            }
        }

        // state heuristics
        if (m_value > 0) m_state = TREND_ACCELERATE;
        else if (m_value < 0) m_state = TREND_DECELERATE;
        else m_state = TREND_MAINTAIN;
        return(true);
    }
    TrendState getState() const { return (m_state); }
    OverheatType getOverheat() const { return (m_overheat); }
    DivergenceType getDivergence() const { return (m_div); }
    double getValue() const { return (m_value); }
    bool   getMACDCross() const { return (m_macdCross); }
    int    getMACDCrossDir() const { return (m_macdCrossDir); }
};

// --------------------- M1 クラス（1分足の取得／判定は OnTimer から呼ぶ） -----
class CTrend1M
{
private:
    int h_bb, h_stoch, h_atr;
public:
    CTrend1M() { h_bb = h_stoch = h_atr = INVALID_HANDLE; }
    void Init(int _h_bb, int _h_stoch, int _h_atr) { h_bb = _h_bb; h_stoch = _h_stoch; h_atr = _h_atr; }
    // Calculate: 更新があったタイミングの OnTimer から呼ぶ。グローバル配列 g_bb*, g_stoch*, g_atr*, g_superTrend* を更新する。
    bool Calculate()
    {
        // OnInit 側でハンドルの検証を行っているためここでは行わない
        const int need = CACHE_BARS;
        double up[], mid[], low[], kArr[], dArr[], atrArr[];
        bool fail_up = false, fail_mid = false, fail_low = false, fail_k = false, fail_d = false, fail_atr = false;

        if (!TryCopyBufferWithRetries(h_bb, 1, 1, need, up)) fail_up = true;
        if (!TryCopyBufferWithRetries(h_bb, 0, 1, need, mid)) fail_mid = true;
        if (!TryCopyBufferWithRetries(h_bb, 2, 1, need, low)) fail_low = true;
        if (!TryCopyBufferWithRetries(h_stoch, 0, 1, need, kArr)) fail_k = true;
        if (!TryCopyBufferWithRetries(h_stoch, 1, 1, need, dArr)) fail_d = true;
        if (!TryCopyBufferWithRetries(h_atr, 0, 1, need, atrArr)) fail_atr = true;

        // 取得失敗があれば処理せず抜ける（最新足の更新もしない）
        if (fail_up || fail_mid || fail_low || fail_k || fail_d || fail_atr)
        {
            return(false);
        }

        ArraySetAsSeries(up, true);
        ArraySetAsSeries(mid, true);
        ArraySetAsSeries(low, true);
        ArraySetAsSeries(kArr, true);
        ArraySetAsSeries(dArr, true);
        ArraySetAsSeries(atrArr, true);

        for (int i = 0; i < need; i++)
        {
            g_bbUpper[i] = up[i];
            g_bbMiddle[i] = mid[i];
            g_bbLower[i] = low[i];
            g_stochK[i] = kArr[i];
            g_stochD[i] = dArr[i];
            g_atr[i] = atrArr[i];
        }

        // SuperTrend を計算してグローバルに保存
        double stVals[CACHE_BARS];
        int stDir[CACHE_BARS];
        ArrayInitialize(stVals, 0.0);
        ArrayInitialize(stDir, 0);
        if (ComputeSuperTrendLocal(_Symbol, PERIOD_M1, atrPeriod, atrMultiplierSL, CACHE_BARS, stVals, stDir))
        {
            for (int i = 0; i < CACHE_BARS; i++)
            {
                g_superTrend[i] = stVals[i];
                g_superTrendDir[i] = stDir[i];
            }
        }
        else
        {
            for (int i = 0; i < CACHE_BARS; i++)
            {
                g_superTrend[i] = 0.0;
                g_superTrendDir[i] = 0;
            }
        }

        // ログ出力（M1 の生データ）
        PrintFormat("M1 更新: BB U/M/L=%.5f/%.5f/%.5f", g_bbUpper[0], g_bbMiddle[0], g_bbLower[0]);
        PrintFormat("M1 更新: Stoch K/D=%.2f/%.2f ATR=%.5f ST=%.5f dir=%d", g_stochK[0], g_stochD[0], g_atr[0], g_superTrend[0], g_superTrendDir[0]);
        return(true);
    }
};

// ===================================================================
// 注文／決済ヘルパー（日本語ログ）
// ===================================================================
double GetAllowedLot(ENUM_ORDER_TYPE type, double price); // 前に宣言済み位置と入れ替え不要（実装は下部）

// 実装は前と同様（省略せずに残す）
// 省略している関数はファイル内で元実装と同等に保持します（省略箇所なし）
// --- ここでは関数をそのまま定義します ---

double GetAllowedLot(ENUM_ORDER_TYPE type, double price)
{
    double equity = AccountInfoDouble(ACCOUNT_EQUITY);
    double allowed_margin = equity * RiskPercentEquity / 100.0;
    double vol_min = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double vol_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    double vol_max = MathMin(SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX), MaxLot);
    if (vol_min <= 0 || vol_step <= 0) return (BaseLot);

    double lo = vol_min, hi = vol_max, mid = vol_min;
    for (int iter = 0; iter < 30; iter++)
    {
        mid = (lo + hi) / 2.0;
        double steps = MathFloor(mid / vol_step + 1e-9);
        mid = steps * vol_step;
        if (mid < vol_min) mid = vol_min;
        double margin = 0;
        if (!OrderCalcMargin(type, _Symbol, mid, price, margin)) break;
        if (margin <= allowed_margin) lo = mid + vol_step; else hi = mid - vol_step;
        if (hi < lo) break;
    }
    double candidate = lo - vol_step;
    candidate = MathMax(vol_min, candidate);
    candidate = MathMin(candidate, vol_max);
    double desired = BaseLot;
    double finalLot = MathMin(candidate, MathMax(vol_min, desired));
    double stepN = MathRound(finalLot / vol_step);
    finalLot = stepN * vol_step;
    finalLot = MathMax(vol_min, MathMin(vol_max, finalLot));
    return (finalLot);
}

bool SendMarketOrder(ENUM_ORDER_TYPE type, double volume, double sl, double tp, bool urgent = false)
{
    double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK), bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double spreadPts = (ask - bid) / _Point;
    if (spreadPts > MaxAllowedSpread) { PrintFormat("発注中止：スプレッドが大きすぎます (%.1f)", spreadPts); return (false); }
    if (!CanReq(urgent)) { Print("発注中止：リクエスト制限により送信不可です。"); return (false); }

    MqlTradeRequest req; MqlTradeResult res; ZeroMemory(req); ZeroMemory(res);
    req.action = TRADE_ACTION_DEAL;
    req.symbol = _Symbol; req.volume = volume; req.deviation = 10; req.type_filling = ORDER_FILLING_FOK;
    req.magic = MagicNumber; req.sl = sl; req.tp = tp; req.type = type;
    if (!OrderSend(req, res))
    {
        PrintFormat("OrderSend 失敗 err=%d ret=%d", GetLastError(), res.retcode);
        return (false);
    }
    RegReq();
    PrintFormat("OrderSend 成功 type=%s ticket=%I64u lot=%.2f price=%.5f", type == ORDER_TYPE_BUY ? "BUY" : "SELL", res.order, volume, res.price);
    return (true);
}

bool ClosePositionByTicket(ulong ticket)
{
    if (!PositionSelectByTicket(ticket)) return (false);
    long ptype = PositionGetInteger(POSITION_TYPE);
    double vol = PositionGetDouble(POSITION_VOLUME);
    if (!CanReq(false)) { Print("決済中止：リクエスト制限により送信不可です。"); return (false); }

    MqlTradeRequest req; MqlTradeResult res; ZeroMemory(req); ZeroMemory(res);
    req.action = TRADE_ACTION_DEAL; req.position = ticket;
    req.symbol = _Symbol; req.volume = vol; req.deviation = 10; req.type_filling = ORDER_FILLING_FOK; req.magic = MagicNumber;
    req.type = (ptype == POSITION_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
    if (!OrderSend(req, res)) { PrintFormat("決済失敗 err=%d ret=%d", GetLastError(), res.retcode); return (false); }
    RegReq();
    PrintFormat("決済成功 ticket=%I64u deal=%I64u", ticket, res.order);
    return (true);
}

bool ModifyPositionSLTP(ulong ticket, double newSL, double newTP)
{
    if (!trade.PositionModify(ticket, newSL, newTP)) { PrintFormat("逆指値更新失敗 err=%d", GetLastError()); return (false); }
    RegReq(); PrintFormat("逆指値更新 成功 ticket=%I64u", ticket); return (true);
}

// ===================================================================
// インスタンスと状態
// ===================================================================
CTrend1H TrendH1;
CTrend15 TrendM15;
CTrend1M TrendM1;

datetime LastH1 = 0, LastM15 = 0, LastM1 = 0;
int TotalPositions = 0, NowPositions = 0, BuyCount = 0, SellCount = 0;

// ===================================================================
// メイン関数群
// ===================================================================
int OnInit()
{
    StartTimeGlobal = TimeCurrent();
    PrintFormat("EA開始時刻: %s", TimeToString(StartTimeGlobal, TIME_DATE | TIME_SECONDS));

    EventSetTimer(1);

    h_adx = iADX(_Symbol, PERIOD_H1, adxPeriod);
    if (h_adx == INVALID_HANDLE) { Print("ADXハンドルの作成に失敗しました。"); return (INIT_FAILED); }

    h_emaS = iMA(_Symbol, PERIOD_H1, emaShortPeriod, 0, MODE_EMA, PRICE_CLOSE);
    h_emaL = iMA(_Symbol, PERIOD_H1, emaLongPeriod, 0, MODE_EMA, PRICE_CLOSE);
    if (h_emaS == INVALID_HANDLE || h_emaL == INVALID_HANDLE) { Print("EMAハンドルの作成に失敗しました。"); return (INIT_FAILED); }

    h_rsi = iRSI(_Symbol, PERIOD_M15, rsiPeriod, PRICE_CLOSE);
    if (h_rsi == INVALID_HANDLE) { Print("RSIハンドルの作成に失敗しました。"); return (INIT_FAILED); }

    h_macd = iMACD(_Symbol, PERIOD_M15, macdFast, macdSlow, macdSignal, PRICE_CLOSE);
    if (h_macd == INVALID_HANDLE) { Print("MACDハンドルの作成に失敗しました。"); return (INIT_FAILED); }

    h_bb = iBands(_Symbol, PERIOD_M1, bbPeriod, bbDeviation, 0, PRICE_CLOSE);
    if (h_bb == INVALID_HANDLE) { Print("BBハンドルの作成に失敗しました。"); return (INIT_FAILED); }

    h_stoch = iStochastic(_Symbol, PERIOD_M1, stochK, stochD, stochSlowing, MODE_SMA, 0);
    if (h_stoch == INVALID_HANDLE) { Print("Stochasticハンドルの作成に失敗しました。"); return (INIT_FAILED); }

    h_atr = iATR(_Symbol, PERIOD_M1, atrPeriod);
    if (h_atr == INVALID_HANDLE) { Print("ATRハンドルの作成に失敗しました。"); return (INIT_FAILED); }

    TrendH1.Init(h_adx, h_emaS, h_emaL);
    TrendM15.Init(h_rsi, h_macd);
    TrendM1.Init(h_bb, h_stoch, h_atr);

    for (int i = 0; i < CACHE_BARS; i++)
    {
        g_bbUpper[i] = g_bbMiddle[i] = g_bbLower[i] = 0.0;
        g_stochK[i] = g_stochD[i] = 0.0;
        g_atr[i] = 0.0;
        g_superTrend[i] = 0.0;
        g_superTrendDir[i] = 0;
    }

    // M15 signal 初期化
    g_M15Signal.barTime = 0;
    g_M15Signal.hasDiv = false;
    g_M15Signal.divType = DIVERGENCE_NONE;
    g_M15Signal.hasMACDCross = false;
    g_M15Signal.macdCrossDir = 0;
    g_M15Signal.pendingNextM1 = false;
    g_M15Signal.usedForEntry = false;
    g_M15Signal.usedForClose = false;

    return (INIT_SUCCEEDED);
}

void OnDeinit(const int reason)
{
    switch (reason)
    {
        case REASON_REMOVE: Print("EAを手動で終了しました。"); break;
        case REASON_CHARTCHANGE:
        case REASON_CHARTCLOSE:
        case REASON_PARAMETERS:
        case REASON_ACCOUNT:
        case REASON_TEMPLATE:
        case REASON_CLOSE: Print("EAが強制終了しました。"); break;
        case REASON_INITFAILED: Print("EAの初期化に失敗しました。"); break;
        default: PrintFormat("EAが終了しました。理由コード: %d", reason); break;
    }

    if (h_adx != INVALID_HANDLE) IndicatorRelease(h_adx);
    if (h_emaS != INVALID_HANDLE) IndicatorRelease(h_emaS);
    if (h_emaL != INVALID_HANDLE) IndicatorRelease(h_emaL);
    if (h_rsi != INVALID_HANDLE) IndicatorRelease(h_rsi);
    if (h_macd != INVALID_HANDLE) IndicatorRelease(h_macd);
    if (h_bb != INVALID_HANDLE) IndicatorRelease(h_bb);
    if (h_stoch != INVALID_HANDLE) IndicatorRelease(h_stoch);
    if (h_atr != INVALID_HANDLE) IndicatorRelease(h_atr);

    EventKillTimer();
    Comment("");
    PrintFormat("終了時の保有ポジション数: %d", PositionsTotal());
}

void OnTick()
{
    double ASK = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double BID = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    if (ASK <= 0 || BID <= 0) { PrintFormat("無効な価格データ ASK= %.3f ,BID= %.3f", ASK, BID); return; }
    double spreadPts = (ASK - BID) / _Point;
    PrintFormat("OnTick: ASK=%.5f BID=%.5f スプレッド(pips)=%.1f", ASK, BID, spreadPts);

    if (spreadPts >= MaxAllowedSpread) { Print("OnTick: スプレッド閾値を超えたため処理を中止します。"); return; }

    // 決済判定（OnTimer で M1 のシグナルが決まっている想定。ただしここでは OnTimer が設定した g_superTrend/g_stoch etc. を参照して実行）
    // 例としてストキャスのクロスでの決済を優先するロジックを示す
    if (g_stochK[1] > g_stochD[1] && g_stochK[0] < g_stochD[0] && g_stochK[0] > stochOverbought)
    {
        // BUY 決済
        for (int i = PositionsTotal() - 1; i >= 0; i--)
        {
            ulong ticket = PositionGetTicket(i);
            if (!PositionSelectByTicket(ticket)) continue;
            if (PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            if ((int)PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
            if (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
            {
                if (ClosePositionByTicket(ticket))
                {
                    PrintFormat("OnTick: ストキャスにより BUY を決済しました ticket=%I64u", ticket);
                    // M15 シグナルの適用状況を更新（初回決済に対する適用）
                    if (g_M15Signal.pendingNextM1 && !g_M15Signal.usedForClose)
                    {
                        g_M15Signal.usedForClose = true;
                        Print("OnTick: M15 シグナル（決済）を適用しました。");
                    }
                }
            }
        }
    }
    else if (g_stochK[1] < g_stochD[1] && g_stochK[0] > g_stochD[0] && g_stochK[0] < stochOversold)
    {
        // SELL 決済
        for (int i = PositionsTotal() - 1; i >= 0; i--)
        {
            ulong ticket = PositionGetTicket(i);
            if (!PositionSelectByTicket(ticket)) continue;
            if (PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            if ((int)PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
            if (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)
            {
                if (ClosePositionByTicket(ticket))
                {
                    PrintFormat("OnTick: ストキャスにより SELL を決済しました ticket=%I64u", ticket);
                    if (g_M15Signal.pendingNextM1 && !g_M15Signal.usedForClose)
                    {
                        g_M15Signal.usedForClose = true;
                        Print("OnTick: M15 シグナル（決済）を適用しました。");
                    }
                }
            }
        }
    }

    // エントリ判定（OnTimer で更新された M1 指標を利用）
    // レンジ: BB タッチ + ストキャス条件
    // トレンド: SuperTrend/EMA/DI 等の整合が取れていること + プルバック
    // M15 シグナル（ダイバージェンス／MACDクロス）が pendingNextM1 の場合は初回の発注に対して補強ロジックとして扱う
    // 実際の発注判断をここで行う（簡易的）

    // 例: レンジ下帯タッチで BUY
    double low = iLow(_Symbol, PERIOD_M1, 1);
    double high = iHigh(_Symbol, PERIOD_M1, 1);
    if ((g_TrendTypeH == TREND_RANGE || g_TrendTypeH == TREND_UNKNOWN) &&
        low <= g_bbLower[0] + 0.5 * _Point && g_stochK[0] < g_stochD[0])
    {
        double price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
        double sl = price - SL_Points * _Point;
        double tp = price + SL_Points * RiskRewardRatio * _Point;
        double lot = MathMin(lot_range, GetAllowedLot(ORDER_TYPE_BUY, price));

        // M15 シグナルがあれば、初回発注に適用してボリュームや条件を微調整（例示）
        if (g_M15Signal.pendingNextM1 && !g_M15Signal.usedForEntry)
        {
            // 例: ダイバージェンス強気の場合追加ボリュームを少し増やす
            if (g_M15Signal.hasDiv && g_M15Signal.divType == DIVERGENCE_BULLISH)
            {
                lot = MathMin(lot * 1.2, MaxLot);
                g_M15Signal.usedForEntry = true;
                Print("OnTick: M15 のダイバージェンス（強気）を初回エントリに適用しました。");
            }
            // MACD ゴールデンクロスがあれば補強
            else if (g_M15Signal.hasMACDCross && g_M15Signal.macdCrossDir == 1)
            {
                lot = MathMin(lot * 1.15, MaxLot);
                g_M15Signal.usedForEntry = true;
                Print("OnTick: M15 の MACD ゴールデンクロスを初回エントリに適用しました。");
            }
        }

        if (lot > 0)
        {
            if (SendMarketOrder(ORDER_TYPE_BUY, lot, sl, tp, false))
                Print("OnTick: レンジ下帯接触により BUY を発注しました。");
        }
    }
    // 例: レンジ上帯タッチで SELL
    if ((g_TrendTypeH == TREND_RANGE || g_TrendTypeH == TREND_UNKNOWN) &&
        high >= g_bbUpper[0] - 0.5 * _Point && g_stochK[0] > g_stochD[0])
    {
        double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
        double sl = price + SL_Points * _Point;
        double tp = price - SL_Points * RiskRewardRatio * _Point;
        double lot = MathMin(lot_range, GetAllowedLot(ORDER_TYPE_SELL, price));

        if (g_M15Signal.pendingNextM1 && !g_M15Signal.usedForEntry)
        {
            if (g_M15Signal.hasDiv && g_M15Signal.divType == DIVERGENCE_BEARISH)
            {
                lot = MathMin(lot * 1.2, MaxLot);
                g_M15Signal.usedForEntry = true;
                Print("OnTick: M15 のダイバージェンス（弱気）を初回エントリに適用しました。");
            }
            else if (g_M15Signal.hasMACDCross && g_M15Signal.macdCrossDir == -1)
            {
                lot = MathMin(lot * 1.15, MaxLot);
                g_M15Signal.usedForEntry = true;
                Print("OnTick: M15 の MACD デッドクロスを初回エントリに適用しました。");
            }
        }

        if (lot > 0)
        {
            if (SendMarketOrder(ORDER_TYPE_SELL, lot, sl, tp, false))
                Print("OnTick: レンジ上帯接触により SELL を発注しました。");
        }
    }
}

void OnTrade()
{
    TotalPositions = PositionsTotal();
    NowPositions = 0; BuyCount = 0; SellCount = 0;
    for (int i = 0; i < TotalPositions; i++)
    {
        ulong ticket = PositionGetTicket(i);
        if (!PositionSelectByTicket(ticket)) continue;
        if (PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if ((int)PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
        NowPositions++;
        if (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) BuyCount++; else SellCount++;
    }
    PrintFormat("OnTrade: ポジション数更新 buy=%d sell=%d total=%d", BuyCount, SellCount, NowPositions);
}

void OnTradeTransaction(const MqlTradeTransaction &trans, const MqlTradeRequest &request, const MqlTradeResult &result)
{
    switch (trans.type)
    {
        case TRADE_TRANSACTION_ORDER_ADD: PrintFormat("注文追加: チケット=%I64u", trans.order); break;
        case TRADE_TRANSACTION_ORDER_DELETE: PrintFormat("注文取消: チケット=%I64u", trans.order); break;
        case TRADE_TRANSACTION_ORDER_UPDATE: PrintFormat("注文更新: チケット=%I64u", trans.order); break;
        case TRADE_TRANSACTION_DEAL_ADD:
            AddTradeHistoryTimestamp(TimeCurrent());
            PrintFormat("約定発生: position=%I64u deal=%I64u", trans.position, trans.deal);
            break;
        case TRADE_TRANSACTION_POSITION:
            PrintFormat("ポジション情報変更: position=%I64u", trans.position);
            break;
        default: break;
    }
}

void OnTimer()
{
    datetime bH1 = iTime(_Symbol, PERIOD_H1, 0);
    datetime bM15 = iTime(_Symbol, PERIOD_M15, 0);
    datetime bM1 = iTime(_Symbol, PERIOD_M1, 0);

    // H1 更新判定
    if (bH1 != LastH1)
    {
        if (TrendH1.Calculate())
        {
            g_TrendTypeH = TrendH1.getType();
            g_TrendStateH = TrendH1.getState();
            g_TrendValueH = TrendH1.getValue();
            PrintFormat("OnTimer: 1時間足更新 時刻=%s Type=%d State=%d ADX=%.3f", TimeToString(bH1, TIME_DATE | TIME_SECONDS), g_TrendTypeH, g_TrendStateH, g_TrendValueH);
            LastH1 = bH1;
        }
        else
        {
            PrintFormat("OnTimer: 1時間足 指標取得失敗 時刻=%s", TimeToString(bH1, TIME_DATE | TIME_SECONDS));
        }
    }

    // M15 更新判定（ダイバージェンスとMACDクロス判定）
    if (bM15 != LastM15)
    {
        if (TrendM15.Calculate(g_TrendTypeH))
        {
            g_TrendStateM15 = TrendM15.getState();
            g_TrendValueM15 = TrendM15.getValue();
            g_DivergenceM15 = TrendM15.getDivergence();
            g_OverheatM15 = TrendM15.getOverheat();

            // M15 シグナルの設定：ダイバ/クロスのいずれかがあれば next M1 足で有効にする
            bool hasDiv = (g_DivergenceM15 != DIVERGENCE_NONE);
            bool hasCross = TrendM15.getMACDCross();
            int crossDir = TrendM15.getMACDCrossDir();

            if (hasDiv || hasCross)
            {
                g_M15Signal.barTime = bM15;
                g_M15Signal.hasDiv = hasDiv;
                g_M15Signal.divType = g_DivergenceM15;
                g_M15Signal.hasMACDCross = hasCross;
                g_M15Signal.macdCrossDir = crossDir;
                g_M15Signal.pendingNextM1 = true;
                g_M15Signal.usedForEntry = false;
                g_M15Signal.usedForClose = false;
                PrintFormat("OnTimer: 15分足更新 時刻=%s Div=%d MACDcross=%d -> 次の1分足で有効", TimeToString(bM15, TIME_DATE | TIME_SECONDS), (int)g_M15Signal.divType, g_M15Signal.macdCrossDir);
            }
            else
            {
                // no signal
                g_M15Signal.pendingNextM1 = false;
                PrintFormat("OnTimer: 15分足更新 時刻=%s Div=なし MACDcross=なし", TimeToString(bM15, TIME_DATE | TIME_SECONDS));
            }

            LastM15 = bM15;
        }
        else
        {
            PrintFormat("OnTimer: 15分足 指標取得失敗 時刻=%s", TimeToString(bM15, TIME_DATE | TIME_SECONDS));
        }
    }

    // M1 更新判定（指標を取得してグローバルに保存）
    if (bM1 != LastM1)
    {
        TrendM1.Calculate();

        // M15シグナルは「次の1分足でのみ有効」なので、ここで pending を消費対象にする（ただし使用フラグはエントリ/決済それぞれで OnTick 側が設定する）
        if (g_M15Signal.pendingNextM1)
        {
            // pending をクリアして、OnTick の次の発注/決済で usedフラグをセットする運用にする
            // pendingNextM1 をここで true->true のままにし、OnTick が利用したら usedForEntry/usedForClose を true にする設計でも可。
            // 実装方針：pendingNextM1 はこの1分足の間だけ true のままとする。次の M1 更新時には自動的に false にする。
            // （つまり、ここでは何もしない。After M1 bar completes, at end we will reset pendingNextM1）
            // Reset will be done after small delay: set a marker that this pending corresponds to this M1 bar.
            // For simplicity: keep pendingNextM1 true now; at the end of this block we set a timestamp for last pending M1 and then clear.
            // We'll store barTimeHandled = LastM1Pending (use bar time)
            // Implement a simple handling: store local variable handled below.
        }

        PrintFormat("OnTimer: 1分足更新 時刻=%s", TimeToString(bM1, TIME_DATE | TIME_SECONDS));

        // After M1 is processed, clear pendingNextM1 so signal only valid for this one M1 bar
        if (g_M15Signal.pendingNextM1)
        {
            // leave usedForEntry/usedForClose as-is; consumer (OnTick) sets them when using
            // After this M1 bar (this call), we will clear pendingNextM1 so it's valid only during this M1 bar window (OnTick calls during this bar will see it)
            // To ensure OnTick sees it, we delay clearing until end of OnTimer; however OnTick is called asynchronously many times per bar.
            // We therefore keep pendingNextM1 true now and set a marker g_M15Signal.barTimeM1Valid = bM1 to indicate which M1 bar it's valid on.
            // For simplicity, set barTime to bM1 and keep pendingNextM1 true; at next M1 update we'll clear it if it hasn't been refreshed.
            g_M15Signal.barTime = bM1;
        }

        if (bM1 != LastM1)
        {
            if (TrendM1.Calculate())
            {
                // M15シグナルは「次の1分足でのみ有効」なので、ここで pending を消費対象にする（ただし使用フラグはエントリ/決済それぞれで OnTick 側が設定する）
                if (g_M15Signal.pendingNextM1)
                {
                    g_M15Signal.barTime = bM1;
                }

                PrintFormat("OnTimer: 1分足更新 時刻=%s", TimeToString(bM1, TIME_DATE | TIME_SECONDS));

                LastM1 = bM1;
            }
            else
            {
                PrintFormat("OnTimer: 1分足 指標取得失敗 時刻=%s", TimeToString(bM1, TIME_DATE | TIME_SECONDS));
            }
        }